#  a key establishment protocol

## 0x01 CA 证书的生成
```
2. Each entity (A, B, C and S) have a Public Key Certificate, ie. CA<<A>>, CA<<B>>, CA<<C>> and CA<<S>>.
```

通过 RSA 算法生成，生成的公钥(public_key) 这里可插入一个 RSA 的参考文献(如维基百科或课程中介绍的)
CA<<A>>, CA<<B>>, CA<<C>> and CA<<S>>

## 0x02 A/B/C 认证到 S, 确认可以使用 S 的服务

```
5. Each Entity must Authenticate itself to the Server S before it is allowed to use its service
```

如下以 A->S的认证为例子 介绍具体的认证过程

S 中保存了 [CA<<A>>, CA<<B>>, CA<<C>> and CA<<S>>] 的 public_key list

A 发送
{
    "action": "login",
    "content": {
        "ca_name": "A_CA_public_key",
        "ca_value": CA<<A>>
    }
}

#### 情况1：
Server check CA<<A>> in CA public list, reply info
{
    "reply_action": "login_success",
    "content": {
        "cookies": sha256(os.urandom(random.randrange(100, 1000))),
        "expired": int(time.time())
    }
}
字段说明：
    cookies 是100-1000长度的随机二进制字符，然后通过 sha256 算法计算得到的一个32长度hash值
    expired 秒计算的时间戳，如果超过一段时间没有发消息 cookies 失效, 默认是 3600 秒
#### 情况2：
Server check CA<<A>> NOT in CA public list, reply info

{
    "reply_action": "login_failed",
    "content": "please use a correct ca public key"
}

## 0x03 确保通过 S 发送的信息没有修改, 验证消息的完整性
```
4.Each step in establishing the Session key (Kabc) must provide an Authenticated Integrity check of the data 
transferred. You must show both sides of this in your protocol design and description, i.e. its generation and 
how it is checked.
```
这里可以通过 RSA 算法，

算法对消息的内容进行签名认证,或者其他任何一种认证算法都OK。

以下以 RSA 为例
下面以 Client-A 通过 Server-S, 发送消息给Client-B 为例，通过RSA签名消息完整性

#### step 1:
Client-A to Server-S 发送消息的结构如下:
{
    "action": "send_msg",
    "content": {
        "cookies": cookies
        "send_soure": A
        "send_to"：B
        "source_signed": RSA.sign(msg, CA<<A>>, hashlib.sha256),
        "msg": {
            "type": msg_type
            "value": msg_content  
        }
    }
}

#### step2
Server-S 检查 cookies, 如果 cookies 有效，将消息转发给 Client-B
不做任何的修改，只是将消息转发给 Client-B
消息的内容如下: 
{
    "action": "send_msg",
    "content": {
        "cookies": cookies
        "send_source": A
        "send_to"：B
        "source_signed": RSA.sign(msg, CA<<A>>, hashlib.sha256),
        "msg": {
            "type": msg_type
            "value": msg_content  
        }
    }
}

#### Step3 
Client-B 收到消息, 开始校验消息的完整性。
如果是当前会话第一次收到来自 A 的消息，向 Server-S 发送请求, 
获取CA<<A>>的 public_key, 然后保存在本地。
当后续协商出来的 Session Kabc 失效的时候，CA<<A>>的 public_key 需要重新获取

##### step3.1 通过 Server-S 获取 client-A 的证书
```
3.The Chat Server, S, has access to all Entity Certificates that use its service and can provide these Certificate to its 
service users if requested to do so
```

消息的内容如下:
Client-B send to Server-S
{
    "action": "request_ca_public_key",
    "content": {
        "ca_name": "A_CA_public_key"
    }
}

Server-S reply to Client-B
{
    "reply_action": "response_ca_public_key",
    "content": {
        "ca_name": "A_CA_public_key"
        "ca_value": PEM-Format
    }
}
##### step3.2 Client-B 校验消息的完整性, 开始校验消息的完整性。
RSA. 引入 CA<<A>>的 public_key, 通过 RSA.sign(msg, CA<<A>>, hashlib.sha256) ，然后分别对 
- source_signed 的消息的发送来源


## 0x04 Kabc 建立(es)
```
6.For each of the steps where you use any of CIA (Confidentiality, Integrity or Authentication) please state the 
algorithm you used to perform that function. This is to be provided in the description you will provide for the 
protocol and also to be listed in the implementation/program comments
```
### 0x04-1 密钥交换算法 ecdh

CURVE25519 椭圆曲线密钥交换算法
elliptic curve Diffie-Hellman

A的公钥  B的私钥  shared_key1
A的私钥  B的公钥  shared_key2
shared_key1 == shared_key2

### 0x04-2 密钥交换过程
Client-A 发送 Client Hello To Client-B

Clinet-A ==> Server-S ==> Client-B
{
    "action": "ecdh",
    "content": {
        "cookies": cookies
        "send_source": A
        "send_to"：B
        "source_signed": RSA.sign(msg, CA<<A>>, hashlib.sha256),
        "msg": {
            "type": "ECDHClient_public_key"
            "value": ECDHClient_public_content  
        }
    }
}

Clinet-B 返回 ServerHello to Client-A

Clinet-A <<== Server-S <<== Client-B
{
    "reply_action": "ecdh",
    "content": {
        "cookies": cookies
        "send_source": B
        "send_to"：A
        "source_signed": RSA.sign(msg, CA<<A>>, hashlib.sha256),
        "msg": {
            "type": "ECDHServer_public_key"
            "value": ECDHServer_public_content  
        }
    }
}

现在 Client-A 有了 Client-B ecdh 产生的 ECDHServer_public_key

通过同样的方法，Client-A 向 Client-C 发送 ECDHClient_public_key

这样 Client-A 和 Client-B 可以计算得到 shared_key_AB
 - ClientHello-Private_key_A 和 ServerHello-Public_key_B
 - ClientHello-Public_key_A 和 ServerHello-Privae_key_B

同样的计算过程，也可以得到 Client-A 和 Client-C 的 shared_key_AC



### 0x04-3 Client-A 产生 Session_Kabc, 并且同步给 B C

通过随机生成字符，并且使用sha256 hash之后，得到长度32的字符串作为 Session_Kabc,
用于 A B C之间的加密会话。

Client-A同步 Session_Kabc 给 Client-B
Client-A ==> Server-S ==> Client-B
{
    "action": "ecdh",
    "content": {
        "cookies": cookies
        "send_source": A
        "send_to"：B
        "source_signed": RSA.sign(msg, CA<<A>>, hashlib.sha256),
        "msg": {
            "type": "AES_encryption"
            "value": AES(Session_Kabc, key=shared_key_AB)
        }
    }
}

Client-A同步 Session_Kabc 给 Client-C
Client-A ==> Server-S ==> Client-C

{
    "action": "ecdh",
    "content": {
        "cookies": cookies
        "send_source": A
        "send_to"：C
        "source_signed": RSA.sign(msg, CA<<A>>, hashlib.sha256),
        "msg": {
            "type": "AES_encryption"
            "value": AES(Session_Kabc, key=shared_key_AC)
        }
    }
}

### 0x04-4 Session_Kabc 的有效期
如果超过 3600 秒没有发送消息， Session_Kabc 自动失效
Client A B C, 每次有消息接收或者发送，Session_Kabc的时间会更新为当前时间


## 0x05  A B C 之间互发消息
例如 A ==> B 发送消息
{
    "action": "send_msg",
    "content": {
        "cookies": cookies
        "send_source": A
        "send_to"：B
        "source_signed": RSA.sign(msg, CA<<A>>, hashlib.sha256),
        "msg": {
            "type": "AES_encryption"
            "value": AES(message_content, key=Session_Kabc)
        }
    }
}

